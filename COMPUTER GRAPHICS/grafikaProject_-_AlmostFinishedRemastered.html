<!DOCTYPE HTML>
<html>
<head>  ///https://www.youtube.com/watch?v=YURsUc6teGA
<meta charset="UTF-8">
<script src="webgl-debug.js"></script>
<script src="gl-matrix-min.js"></script>

<script id="vShader" type="x-shader/x-vertex">

attribute vec4 aVertexPosition;
// attribute vec4 aVertexColor; // No colour needed 
uniform mat4 uPerspectiveViewTransform;
uniform mat4 uModelTransform; 
attribute vec2 aTextureCoordinates; //  το attribute του σημείου της εικόνας texture (2άδα αριθμών) by Amanda // SHOULD BE ATTRIBUTE  ATTRIBUTE, NOT  VARYING
// varying του texture  που μεταφέρει πληροφορία στο fragment shader
varying vec2 vTextureCoordinates;

//CHANGE 8 --> HELPING ATTRIBUTES FOR CHANGES IN VSHADER 

attribute vec4 cubeVertexPosition;
attribute vec2 aCubeTextureCoord;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

varying highp vec2  vCubeTextureCoord;

// varying vec4 vColor; // IT IS THE SAME HERE 
void main() {
    gl_Position =  uPerspectiveViewTransform * uModelTransform * aVertexPosition;
    // vColor = aVertexColor; // SAME HERE
    //	δίνονται οι συντεταγμένες που ήρθαν στο αντίστοιχο νέο attribute (texture)
    vTextureCoordinates = aTextureCoordinates;  
    vCubeTextureCoord = aTextureCoordinates;

    //CHANGE 9 -> FRAGMENT SHADER'S TURN 
}
</script>

<script id="fShader" type="x-shader/x-fragment">
precision mediump float;

varying highp vec2 vCubeTextureCoord;//declared here as well as in the vShader
// ΑΛΛΑΓΕΣ 1, ΕΔΩ ΕΙΧΕ ΕΝΑ x ΚΑΙ ΧΤΥΠΟΥΣΕ ΕΡΡΟΡ

//To varying για την υφή δηλώνεται και στον fragmentShader
varying vec2 vTextureCoordinates;

uniform sampler2D uniformSampler;

void main() {
   
    gl_FragColor = texture2D(uniformSampler,vCubeTextureCoord); // TEXTURE INSTEAD OF COLOUR  //ΑΛΛΑΓΕΣ 2, ΕΔΩ ΗΤΑΝ uSampler ΕΝΩ ΕΔΩ ΕΧΟΥΜΕ uniformSampler (ΠΟΥ ΕΙΧΕΣ ΦΤΙΑΞΕΙ)
    //INSTEAD OF ASSIGNING A COLOR VALUE TO THE FRAGMENT'S COLOR , THE FRAGMENT'S COLOUR 
    //THE FRAGMENT'S COLOUR IS COMPUTED BY FETCHING THE TEXTURE ELEMENT (PIXEL WITHIN THE TEXTURE)
    //BASED ON THE VALUEOF  vCubeTextureCoord WHICH LIKE THE COLOURS IS INTERPOLATED WITHIN THE VERTICES 
    
    //NOTE : UPDATE THE programInfo DECLARATION IN THE MAIN

    //για τις υφές χρησιμοποιούμε το uniformSampler και την συνάρτηση (βιβλιοθήκης ) texture2D για να επιλεγεί το κατάλληλο texture pixel από την εικόνα του ξύλου
    // η εικόνα του ξύλου και του ουρανού θα συμπεριληφθεί αργότερα

    gl_FragColor = texture2D(uniformSampler, vTextureCoordinates);
    //CHANGE 9 -UPDATING SHADER FOR CUBE COORDINATES 
    //A FRAGMENT'S COLOR IS COMPUTED BY FETCHING THE TEXEL (PIXEL WITHIN TEXTURE )BASED ON THE VALUE WITHIN THE vCubeTextureCoord
    //WHICH IS INTERPOLATED BETWEEN THE 2 VERTICES 

    //BECAUSE WE CHANGED AN ATTRIBUTE & ADDED A UNIFORM WE NEEED TO CHECK LOCATIONS 
    //AND ALSO MAKE SOME CHANGES IN THE drawScene

}
</script>

<script>
var gl;
var canvas;
var shadersProgram;
var vertexPositionAttributePointer;
var vertexColorAttributePointer;
var perspectiveViewUniformPointer;
var modelUniformPointer; 
var vertexBuffer;
var colorBuffer;
var indexBuffer;
var skyCubeVBuffer; //declaring new buffer for cube 
var requestID = 0;
var perspectiveMatrix = new Float32Array(16);
var viewMatrix = new Float32Array(16);
var pvMatrix = new Float32Array(16);
var translationMatrix = new Float32Array(16);
var scaleMatrix = new Float32Array(16);
var finalMatrix = new Float32Array(16);
var flag=1;
//δήλωση global μεταβλητής για τον δείκτη θέσης του attribute για την υφή 
var textureCoordinatesAttributePointer;
//δήλωση global μεταβλητής για τον δείκτη στη θέση του νέου uniform που δηλώθηκε στο fragment shader
var uSamplerPointer;
//buffer gia to texture  tou trapeziou (vertices)
var tableVbuffer;
//Index Buffer for table texture  
var tableIbuffer;
//new common buffer for all textures (for code simplicity )
var textureBuffer;
//2 new global variables as texture objects
var cubeTexture;    //texture for skycube
var tableTexture;
//var skyCubeTextureCoordinates;


//texture object for skycube or skybox 
var skycubeTexture;

function createGLContext(inCanvas) {
    var outContext = null;
    outContext = inCanvas.getContext("webgl");
    if (!outContext)
        outContext = inCanvas.getContext("experimental-webgl");
    if (!outContext)
        alert("WebGL rendering context creation error.");

    return outContext;
}

function createCompileShader(shaderType, shaderSource) {
    var outShader = gl.createShader(shaderType);
    gl.shaderSource(outShader, shaderSource);
    gl.compileShader(outShader);
    if (!gl.getShaderParameter(outShader, gl.COMPILE_STATUS)) {
        alert("Shader compilation error. " + gl.getShaderInfoLog(outShader));
        gl.deleteShader(outShader);
        outShader = null;
    }
    return outShader;
}

function initShaders() {
    var vertexShaderSource = document.getElementById("vShader").textContent;
    var fragmentShaderSource = document.getElementById("fShader").textContent;
    var vertexShader = createCompileShader(gl.VERTEX_SHADER, vertexShaderSource);
    var fragmentShader = createCompileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
    shadersProgram = gl.createProgram();
    gl.attachShader(shadersProgram, vertexShader);
    gl.attachShader(shadersProgram, fragmentShader);
    gl.linkProgram(shadersProgram);
    if (!gl.getProgramParameter(shadersProgram, gl.LINK_STATUS)) {
        alert("Shaders linking error.");
    }
    gl.useProgram(shadersProgram);
    vertexPositionAttributePointer = gl.getAttribLocation(shadersProgram, "aVertexPosition");
    gl.enableVertexAttribArray(vertexPositionAttributePointer);
   // vertexColorAttributePointer = gl.getAttribLocation(shadersProgram, "aVertexColor");  // POINTER FOR COLOUR NOT NEEDED
   // gl.enableVertexAttribArray(vertexColorAttributePointer);

    //turn on the texture attribute through the pointer
    textureCoordinatesAttributePointer= gl.getAttribLocation(shadersProgram, "aTextureCoordinates");
	gl.enableVertexAttribArray(textureCoordinatesAttributePointer);
    //CHANGE 10 : BOOKMARK
    cubeVertexPosition : gl.getAttribLocation(shadersProgram,"aVertexPosition");




    modelUniformPointer = gl.getUniformLocation(shadersProgram, "uModelTransform"); 

    perspectiveViewUniformPointer = gl.getUniformLocation(shadersProgram, "uPerspectiveViewTransform");

    //same here for uniformSampler
    uSamplerPointer = gl.getUniformLocation(shadersProgram, "uniformSampler");

    //CHANGE 7 BEING CONTINUED
    //KEY : FETCHING THE TEXTURE COORDS & PASSING THEM TO THE VERTEX SHADER 
    //THIS WILL INDICATE THE LOCATION WITHIN THE TEXTURE CORRESPONDING TO THE VERTEX 
    //LIKEWISE THE FRAGMENT SHADER SHOULD BE UPDATED   (FOR THE CUBE)


}

function initBuffers() {

//Φτιάχνω το τετράεδρο με την αρχή των αξόνων στο κ΄έντρο του εσωτερικού έτσι ώστε να μπορεί να γίνει scaling για το skycube
//den xreiazomai xrwmata giati paizw me tis yfes
//τετράεδρο = χώρος για τον ουρανό 
var tetraedroVertices = new Float32Array([
			 0.0,  0.0, 0.2, 1.0,  // vertex Α
			-0.2, -0.2, -0.2, 1.0, // vertex Β
			 0.2, -0.2, -0.2, 1.0, // vertex C
			 0.0,  0.2, -0.2, 1.0   // vertex D
				]);
	vertexBuffer = gl.createBuffer(); 
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); 
	gl.bufferData(gl.ARRAY_BUFFER, tetraedroVertices,	gl.STATIC_DRAW); 
	vertexBuffer.itemSize = 4;  
	vertexBuffer.itemCount = 4;


    var indexMatrix = new Uint16Array([
		0,1,2,  // ABC
		0,2,3,  // ACD
		0,3,1,  // ADB
		1,3,2  // BDC
		]);
	indexBuffer = gl.createBuffer(); 
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); 
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexMatrix,gl.STATIC_DRAW);
	indexBuffer.itemCount = 12; 
    //end for vertices pointers  for tetraedro

//FLOOR 
//FLOOR SHOULD BE UNDER THE TABLE TO GIVE A SENSE OF SPACE
var floorVertices = new Float32Array([              //floor should  be from -25 to 25
		 -25,  25, -15, 1,  // VERTEX A
		  25,  25, -15, 1,  // VERTEX B
		 -25, -25, -15, 1,  // VERTEX C
		  25, -25, -15, 1   // VERTEX D
		]);

        floorVBuffer = gl.createBuffer(); 
	    gl.bindBuffer(gl.ARRAY_BUFFER, floorVBuffer); 
	    gl.bufferData(gl.ARRAY_BUFFER, floorVertices,	gl.STATIC_DRAW); 
	    floorVBuffer.itemSize = 4;  
	    floorVBuffer.itemCount = 4;

        
	var floorIMatrix = new Uint16Array([
		0,1,2,  // ABC
		1,2,3,  // BCD
		]);
	floorIBuffer = gl.createBuffer(); 
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, floorIBuffer); 
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, floorIMatrix, gl.STATIC_DRAW);
	floorIBuffer.itemCount = 6; 
    //END FLOOR

    //same as floor but for cube 
    skyCubeVBuffer = gl.createBuffer(); //CHANGES 4 
    gl.bindBuffer(gl.ARRAY_BUFFER,skyCubeVBuffer);
    const skyCubeTextureCoordBuffer = gl.createBuffer();//CHANGES 5 CREATING BUFFER FOR COORDS OF TXTURE FOR SKYCUBE
    gl.bindBuffer(gl.ARRAY_BUFFER,skyCubeTextureCoordBuffer);
 /*   //CHANGES 5 -> COORDINATES FOR TEXTURE OF SKYCUBE 
    const skyCubeTextureCoordinates = newFloat32Array([ //CHANGES 6 //---> SOS AN ERROR OCCURS HERE 
    //FRONT 
    0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,
    //BACK 
    0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,               // ----> puting this inside initBuffers() function
    //TOP
    0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,
    //BOTTOM 
    0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,

    ]);

   // gl.bufferData(
  //      gl.ARRAY_BUFFER,
   //     newFloat32Array(skyCubeTextureCoordinates),
 //       gl.STATIC_DRAW,
    );*/
    //FIRST THIS CODE CREATES A WEBGL BUFFER INTO WHICH WE WILL STORE THE TEXTURE COORDINATES FOR EACH FACE OF THE CUBE 
    //THEN WE BIND THE BUFFER AS THE ARRAY WE WILL BE WRITING INTO 

    //THE skyCubeTextureCoordinatesArray  defines the texture coords to the corresponding of each vertex of the face
    //REMEMBER : TEXTURE COORDINATES RANGE FROM 0.0 TO 1.0 -> THE DIMENSIONS OF TEXTURES ARE NORMALIZED TO A RANGE OF 0.0 TO 1.0 
    //REGARDLESS OF THEIR ACTUAL SIZE --> FOR BETTER MAPPING

    //ONCE WE'VE SET UP THE TEXTURE MAPPING ARRAY WE PASS THE ARRAY TO THE BUFFER  SO THAT WBGL HAS THE DATA READY FOR USE 
    //THEN WE RETURN THE NEW BUFFER 
    //THEN WE UPDATE THE INITBUFFERS FUNC TO RETURN  & CREATE THE TEXTURE COORDS BUFFER
    //end cube


    //create texture buffer -> enable buffer

    floorTextureBuffer = gl.createBuffer(); 
	gl.bindBuffer(gl.ARRAY_BUFFER, floorTextureBuffer);
	var floorTextureCoordinates=[0.0,1.0,
							1.0,1.0,
							0.0,0.0,
							1.0,0.0];
	//these coordinates are the points of texture image where the index buffer will take color from
    tetraTexture = gl.createTexture();
    //image for tetraedro -> the tetraedro has sky like image
    var tetraImageURL = "Aesthetic-Night-Sky.jpg";
    preprocessTextureImage(tetraImageURL, tetraTexture); //this function will be defined later
    
    //image for floor -> the floor has water like image
    floorTexture = gl.createTexture();
	var floorImageURL ="waterfloor.jpg";
	preprocessTextureImage(floorImageURL, floorTexture);

    skycubeTexture = gl.createTexture();
	var skycubeImageURL = "Aesthetic-Night-Sky.jpg";
	preprocessTextureImage(skycubeImageURL, skycubeTexture);

    //function to combine texture object  image plus image preprocessing 

    function preprocessTextureImage(imageURL, textureObject) {
// 	creating object image
	var imageObject = new Image();
	//image object runs here
	imageObject.onload = function() {    
		//enabling texture parameter
		gl.bindTexture(gl.TEXTURE_2D, textureObject);
		// flipping y --> image from top to bottom
       	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		// flipping image in enabled texture
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imageObject);
		//how new pixels will be created
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
		gl.generateMipmap(gl.TEXTURE_2D);
	};
	//load image
	imageObject.src = imageURL;	
}

    //create texture object for tetraedro

    var cubeVertices = new Float32Array([                   ///----BOOKMARK -----BOOKMARK ----BOOKMARK
        //Front Face
        -1.0, -1.0, 1.0, 1.0,
        1.0, -1.0, 1.0, 1.0,
        1.0, 1.0, 1.0, 1.0,
        -1.0, 1.0, 1.0, 1.0,

        //Top Face
        -1.0, 1.0, 1.0, 1.0,
        1.0, 1.0, 1.0, 1.0,
        1.0, 1.0, -1.0, 1.0,
        -1.0, 1.0, -1.0, 1.0,

        //Bottom Face
        -1.0, -1.0, -1.0, 1.0,
        1.0, -1.0, -1.0, 1.0,
        1.0, -1.0, 1.0, 1.0,
        -1.0, -1.0, 1.0, 1.0,

        //Right Face
        -1.0, -1.0, -1.0, 1.0,
        -1.0, -1.0, 1.0, 1.0,
        -1.0, 1.0, 1.0, 1.0,
        -1.0, 1.0, -1.0, 1.0,

        //Left Face
        1.0, -1.0, 1.0, 1.0,
        1.0, -1.0, -1.0, 1.0,
        1.0, 1.0, -1.0, 1.0,
        1.0, 1.0, 1.0, 1.0,

        //Back Face
        -1.0, -1.0, -1.0, 1.0,
        1.0, -1.0, -1.0, 1.0,
        1.0, 1.0, -1.0, 1.0,
        -1.0, 1.0, -1.0, 1.0
    ]);

    vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);
    vertexBuffer.itemSize = 4;
    vertexBuffer.itemCount = 24;

    textureBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
	var textureCoordinates = [
    // Back face
    0.0, 0.0,
    1.0, 0.0,
    0.0, 1.0,
    1.0, 1.0,
    // Right face
    0.0, 0.0,
    1.0, 0.0,
    0.0, 1.0,
    1.0, 1.0,
    // Front face
    0.0, 0.0,
    1.0, 0.0,
    0.0, 1.0,
    1.0, 1.0,
    // Left face
    0.0, 0.0,
    1.0, 0.0,
    0.0, 1.0,
    1.0, 1.0,
    // Bottom face
    0.0, 0.0,
    1.0, 0.0,
    0.0, 1.0,
    1.0, 1.0,
    // Top face
    0.0, 0.0,
    1.0, 0.0,
    0.0, 1.0,
    1.0, 1.0
            ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);
    textureBuffer.itemSize = 2;

    //Τώρα μένει να φτιαχτεί ένας ακόμα textureBuffer για τον κύβο , να βάλουμε όλες τις κορυφές
    // όπως κάναμε με το πάτωμα και να αντιστοιχίσουμε όλες τις κορυφές του textureBuffer με τον κύβο.
    // cubeTexture = loadTexture(gl, "Aesthetic-Night-Sky.jpg"); //CHANGE 1 // ΑΛΛΑΓΕΣ 3, ΔΕΝ ΧΡΕΙΑΖΕΤΑΙ ΝΑ ΤΟ ΦΟΡΤΩΣΕΙΣ, ΕΧΕΙΣ ΚΑΝΕΙ Ο,ΤΙ ΠΡΕΠΕΙ ΑΠΟ ΠΡΙΝ (ΕΠΙΣΗΣ ΧΤΥΠΑΕΙ ΕΡΡΟΡ ΓΙΑΤΙ ΛΕΕΙ ΟΤΙ ΔΕΝ ΕΙΝΑΙ DEFINED)
    //FLIP IMAGE PIXELS THE WAY WEBGL EXPECTS IT TO HAPPEN
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); //CHANGE 2 
    //CHANGE 3 MAPPING THE TEXTURE TO THE FACES (ALWAYS FOR THE CUBE)
    //AT THIS POINT TEXTURE IS LOADED AND SET READY FOR USE 
    //BUT FIRST WE NEED TO ESTABLISH THE MAPPING FOR THE TEXTURE COORDINATES TO THE VERTICES OF THE FACES OF THE CUBE 
    //WE ARE ADDING THE PROPER CODE INSIDE THE FUNCTION  initBuffers()  (inside here)

    //CHANGES 5 -> COORDINATES FOR TEXTURE OF SKYCUBE 
    // const skyCubeTextureCoordinates = new Float32Array([ //CHANGES 6 ---> SOS AN ERROR OCCURS HERE // ΑΛΛΑΓΕΣ 4.1 ΠΡΟΣΟΧΗ, ΗΤΑΝ ΚΟΛΛΗΤΑ ΤΟ new ΜΕ ΤΟ Float32Array
    // //FRONT 
    // 0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,
    // //BACK 
    // 0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,
    // //TOP
    // 0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,
    // //BOTTOM 
    // 0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,             // ΑΛΛΑΓΕΣ 4.1.1 ΒΑΣΙΚΑ ΤΟ ΕΒΑΛΑ ΟΛΟ ΣΕ COMMENT, ΔΙΟΤΙ ΔΕΝ ΧΡΕΙΑΖΕΤΑΙ ΝΑ ΚΑΝΕΙΣ ΚΙ ΑΛΛΟ BUFFER ΚΥΒΟΥ ΓΙΑ ΤΟΝ ΟΥΡΑΝΟ, ΜΠΟΡΕΙΣ ΝΑ ΧΡΗΣΙΜΟΠΟΙΗΣΕΙΣ ΤΟΝ ΙΔΙΟ ΠΟΥ ΕΧΕΙΣ ΓΙΑ ΤΑ ΕΠΙΠΛΑ
    
    // ]);

    // gl.bufferData(
    //     gl.ARRAY_BUFFER,
    //     new Float32Array(skyCubeTextureCoordinates), // ΑΛΛΑΓΕΣ 4.2 ΚΑΙ ΕΔΩ
    //     gl.STATIC_DRAW,
    // );

    //CHANGE 7 -->  UPDATE THE SHADER SO THAT IT WILL FETCH TEXTURE DATA 
    

    //Here it creates the right and left triangles in order to make the rectangle of the face
    var cubeIndices = new Uint16Array([
        0, 1, 2,  0, 2, 3,
        4, 5, 6,  4, 6, 7,
        8, 9, 10,  8, 10, 11,
        12, 13, 14,  12, 14, 15,
        16, 17, 18,  16, 18, 19,
        20, 21, 22,  20, 22, 23 
    ]);
    indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);
    indexBuffer.itemCount = 36; 
}

function drawScene() { 
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(vertexPositionAttributePointer, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
    // gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer); // THERE IS NO COLOUR BUFFER SO WE DON'T CALL IT 
    // gl.vertexAttribPointer(vertexColorAttributePointer, colorBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);


    var txtViewAngle;
    txtViewAngle =  document.getElementById("viewAngle").value;
    var numViewAngle = parseFloat(txtViewAngle);
    numViewAngle = numViewAngle*Math.PI/180.0;

    //Here we get the input of the distance and the radio button which is checked.
    var viewDistance = document.getElementById("viewDistance").value;
    var viewCameraButtons = document.getElementsByName("viewCameraButton");
    var numViewCamera;
    
    for (var i = 0; i < viewCameraButtons.length; i++) {
        if (viewCameraButtons[i].checked) {
            numViewCamera = parseInt(viewCameraButtons[i].value);
            break;
        }
    }


    //This is where the radio buttons function
    switch(numViewCamera){
        case 0:
            glMatrix.mat4.lookAt(viewMatrix, [-viewDistance, viewDistance, viewDistance], [0, 0, 0], [0, 0, 1]);
            break;
        case 1:
            glMatrix.mat4.lookAt(viewMatrix, [-viewDistance, viewDistance, -viewDistance], [0, 30, 0], [0, 40, 1]);   // [0, 0, 0], [0, 0, 1]);
            break;
        case 2:
            glMatrix.mat4.lookAt(viewMatrix, [-viewDistance, -viewDistance, viewDistance], [0, 0, 0], [0, 0, 1]);
            break;
        case 3:
            glMatrix.mat4.lookAt(viewMatrix, [-viewDistance, -viewDistance, -viewDistance], [0, 0, 0], [0, 0, 1]);
            break;
        case 4:
            glMatrix.mat4.lookAt(viewMatrix, [viewDistance, viewDistance, viewDistance], [0, 0, 0], [0, 0, 1]);
            break;
        case 5:
            glMatrix.mat4.lookAt(viewMatrix, [viewDistance, viewDistance, -viewDistance], [0, 0, 0], [0, 0, 1]);
            break;
        case 6:
            glMatrix.mat4.lookAt(viewMatrix, [viewDistance, -viewDistance, viewDistance], [0, 0, 0], [0, 0, 1]);
            break;
        case 7:
            glMatrix.mat4.lookAt(viewMatrix, [viewDistance, -viewDistance, -viewDistance], [0, 0, 0], [0, 0, 1]);
            break;
        default:
    }

    //glMatrix.mat4.lookAt(viewMatrix, [viewDistance, viewDistance, viewDistance], [0, 0, 0], [0, 0, 1]);
    if(flag==1){
        glMatrix.mat4.perspective(perspectiveMatrix, numViewAngle, 1, 0.01, 1000);
        flag=0;
    }else{
        glMatrix.mat4.perspective(perspectiveMatrix, numViewAngle, 1, 0.01, 1000*100);
    }

    glMatrix.mat4.multiply(pvMatrix, perspectiveMatrix, viewMatrix);
    gl.uniformMatrix4fv(perspectiveViewUniformPointer, false, pvMatrix);

    //Table Leg1, just like in Exercise 6 but without the loop.
    
    //enable  first available texture unit // WE BROUGHT THE CODE FOR TABLE TEXTURE OVER THE TABLE DESIGN
    gl.activeTexture(gl.TEXTURE0);
    //combine it with the texture we choose and enable it 
    gl.bindTexture(gl.TEXTURE_2D, tetraTexture);
    //update uniform for the specified , enabled texture units 
    gl.uniform1i(uSamplerPointer, 0);
    //enable texture buffer
    gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
    //update related attribute 
    gl.vertexAttribPointer(textureCoordinatesAttributePointer, textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

    glMatrix.mat4.fromTranslation(translationMatrix, [19, 19, 1]); //Coordinates of the leg, [x, y, z], x goes to the left, y goes to the right and z is the y axis.
    glMatrix.mat4.fromScaling(scaleMatrix, [1, 1, 15]);//Size of the leg
    glMatrix.mat4.multiply(finalMatrix, translationMatrix, scaleMatrix);
    gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
    gl.drawElements(gl.TRIANGLES, indexBuffer.itemCount, gl.UNSIGNED_SHORT, 0);

    //Table Leg2
    glMatrix.mat4.fromTranslation(translationMatrix, [-19, -19, 1]);
    glMatrix.mat4.fromScaling(scaleMatrix, [1, 1, 15]);
    glMatrix.mat4.multiply(finalMatrix, translationMatrix, scaleMatrix);
    gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
    gl.drawElements(gl.TRIANGLES, indexBuffer.itemCount, gl.UNSIGNED_SHORT, 0);

    //Table Leg3
    glMatrix.mat4.fromTranslation(translationMatrix, [19, -19, 1]);
    glMatrix.mat4.fromScaling(scaleMatrix, [1, 1, 15]);
    glMatrix.mat4.multiply(finalMatrix, translationMatrix, scaleMatrix);
    gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
    gl.drawElements(gl.TRIANGLES, indexBuffer.itemCount, gl.UNSIGNED_SHORT, 0);

    //Table Leg4
    glMatrix.mat4.fromTranslation(translationMatrix, [-19, 19, 1]);
    glMatrix.mat4.fromScaling(scaleMatrix, [1, 1, 15]);
    glMatrix.mat4.multiply(finalMatrix, translationMatrix, scaleMatrix);
    gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
    gl.drawElements(gl.TRIANGLES, indexBuffer.itemCount, gl.UNSIGNED_SHORT, 0);

    //Table Top
    glMatrix.mat4.fromTranslation(translationMatrix, [0, 0, 15]);
    glMatrix.mat4.fromScaling(scaleMatrix, [20, 20, 1]);
    glMatrix.mat4.multiply(finalMatrix, translationMatrix, scaleMatrix);
    gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
    gl.drawElements(gl.TRIANGLES, indexBuffer.itemCount, gl.UNSIGNED_SHORT, 0);

    //Skamni Leg1
    glMatrix.mat4.fromTranslation(translationMatrix, [-16, 14, 0.5]);
    glMatrix.mat4.fromScaling(scaleMatrix, [0.5, 0.5, 7.5]);
    glMatrix.mat4.multiply(finalMatrix, translationMatrix, scaleMatrix);
    gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
    gl.drawElements(gl.TRIANGLES, indexBuffer.itemCount, gl.UNSIGNED_SHORT, 0);

    //Skamni Leg2
    glMatrix.mat4.fromTranslation(translationMatrix, [-16, -5, 0.5]);
    glMatrix.mat4.fromScaling(scaleMatrix, [0.5, 0.5, 7.5]);
    glMatrix.mat4.multiply(finalMatrix, translationMatrix, scaleMatrix);
    gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
    gl.drawElements(gl.TRIANGLES, indexBuffer.itemCount, gl.UNSIGNED_SHORT, 0);

    //Skamni Leg3
    glMatrix.mat4.fromTranslation(translationMatrix, [-35, 14, 0.5]);
    glMatrix.mat4.fromScaling(scaleMatrix, [0.5, 0.5, 7.5]);
    glMatrix.mat4.multiply(finalMatrix, translationMatrix, scaleMatrix);
    gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
    gl.drawElements(gl.TRIANGLES, indexBuffer.itemCount, gl.UNSIGNED_SHORT, 0);

    //Skamni Leg4
    glMatrix.mat4.fromTranslation(translationMatrix, [-35, -5, 0.5]);
    glMatrix.mat4.fromScaling(scaleMatrix, [0.5, 0.5, 7.5]);
    glMatrix.mat4.multiply(finalMatrix, translationMatrix, scaleMatrix);
    gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
    gl.drawElements(gl.TRIANGLES, indexBuffer.itemCount, gl.UNSIGNED_SHORT, 0);

    //Skamni Top
    glMatrix.mat4.fromTranslation(translationMatrix, [-25.5, 4.5, 7.5]);
    glMatrix.mat4.fromScaling(scaleMatrix, [10, 10, 0.5]);
    glMatrix.mat4.multiply(finalMatrix, translationMatrix, scaleMatrix);
    gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
    gl.drawElements(gl.TRIANGLES, indexBuffer.itemCount, gl.UNSIGNED_SHORT, 0);

    //Skamni plath //translationMatrix[x,z,y] 
    glMatrix.mat4.fromTranslation(translationMatrix, [-35.5, 5, 16]); // move object in space///PWS THA TO KANW KATHETO STO APO PANW
    glMatrix.mat4.fromScaling(scaleMatrix, [ 0.5,10,10]);  //change its shape--> stays the same here
    glMatrix.mat4.multiply(finalMatrix, translationMatrix, scaleMatrix);
    gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
    gl.drawElements(gl.TRIANGLES, indexBuffer.itemCount, gl.UNSIGNED_SHORT, 0);


//tetraedro
    // gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); 
	// gl.vertexAttribPointer(vertexPositionAttributePointer, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);


    

    /* for (var q = -0.5; q<=0.5; q+=0.5) // THIS ISN'T NEEDED, BECAUSE WE ARE NOT MAKING 3 TETRAEDRA
	{
		glMatrix.mat4.fromTranslation(translationMatrix,[q,q,0]);
		gl.uniformMatrix4fv(modelUniformPointer, false, translationMatrix); 
		gl.drawElements(gl.TRIANGLES,indexBuffer.itemCount,gl.UNSIGNED_SHORT, 0);
	}
    */ 

    //end of tetraedro


    //starting with floor       BREAKPOINT 
    //floor --> water
    gl.bindBuffer(gl.ARRAY_BUFFER, floorVBuffer); 
	gl.vertexAttribPointer(vertexPositionAttributePointer, floorVBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, floorTexture); 
	gl.uniform1i(uSamplerPointer, 1);
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, floorIBuffer);

    glMatrix.mat4.identity(finalMatrix);
	gl.uniformMatrix4fv(modelUniformPointer, false, finalMatrix); 
	gl.drawElements(gl.TRIANGLES,floorIBuffer.itemCount,gl.UNSIGNED_SHORT, 0);

    //end of floor

//for skycube 
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); 
	gl.vertexAttribPointer(vertexPositionAttributePointer, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

	gl.activeTexture(gl.TEXTURE2);
    //BIND TEXTURE TO TEXTURE UNIT  
	gl.bindTexture(gl.TEXTURE_2D, skycubeTexture); //EGRAFE skyboxTexture PRIN KAI TO ALLAKSA SE skycubeTexture AFOY EINAI DHLWMENO ETSI

    //
	gl.uniform1i(uSamplerPointer, 2);
	
	gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);

	gl.vertexAttribPointer(textureCoordinatesAttributePointer, textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	
	glMatrix.mat4.fromScaling(scaleMatrix,[200,200,200]);
	gl.uniformMatrix4fv(modelUniformPointer, false, scaleMatrix); 
	gl.drawElements(gl.TRIANGLES,indexBuffer.itemCount,gl.UNSIGNED_SHORT, 0);
    
///skycube
//CHANGE 11
//WE NEED TO ADD CODE TO LOAD THE TECTURES 
//IN THIS CASE WE ARE USING ONE TEXTURE , MAPPED ONTO ALL SIX SIDES OF OUR ROTATING CUBE
//THELOADING OF TEXTURES FOLLOWS CROSS DOMAIN RULES
//INIT TEXTURE & LOAD AN IMAGE
//WHEN IMAGE FIISHES LOADING ADD IT TO TEXTURE

//UPDATE TEXTURE WITH CONTENTS OF IMAGE
// const pixel = new Uint8Array([0,0,255,255]);

// gl.texImage2D(

// gl.TEXTURE_2D,
// 0,          //LEVEL
// gl.RGBA,    //INTERNAL FORMAT
// 1,          //WIDTH 
// 1,           //HEIGHT
// 0,           //BORDER
// gl.RGBA,    //SOURCE FORMAT
// gl.UNSIGNED_BYTE,            //SOURCE TYPE
// pixel,
// );

// //CHANGE 12 

// 	var skycubeImageURL = "Aesthetic-Night-Sky.jpg";
// 	//preprocessTextureImage(skycubeImageURL, skycubeTexture);
//     const skyCubeImage = new Image();
//     skyCubeImage.onload = () =>{
//         gl.bindTexture(gl.TEXTURE_2D,skycubeTexture);
//         gl.textImage2D(
//         gl.TEXTURE_2D,
//         0,          //LEVEL
//         gl.RGBA,    //INTERNAL FORMAT
//         gl.RGBA,    //SOURCE FORMAT
//         gl.UNSIGNED_BYTE,            //SOURCE TYPE
//         skyCubeImage,
//         );
//     }

    // if (isPowerOf2(skyCubeImage.width)) ////BOOKMARK ---- BOOKMARK ----- BOOKMARK https://www.youtube.com/watch?v=iNNUsRuwp94
    // {

    // }else{



    // }

}
//varying vec2 v_texcoord;
//attribute vec2 a_texcoord;


function main() {

    minDimension = Math.min(window.innerHeight, window.innerWidth);
    canvas = document.getElementById("sceneCanvas");
    canvas.width = 0.9 * minDimension;
    canvas.height = 0.9 * minDimension;
    gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas));
    initShaders();
    initBuffers();
    gl.clearColor(0.5, 0.5, 0.5, 1.0);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.enable(gl.DEPTH_TEST);
    drawScene();
}

function startAnimation() {
    if (requestID == 0)
        requestID = window.requestAnimationFrame(animationStep);
}

function animationStep() {
    drawScene();
    requestID = window.requestAnimationFrame(animationStep);
}

function stopAnimation() {
    window.cancelAnimationFrame(requestID);
    requestID = 0;
}
</script>
</head>

<body onload="main()">
<canvas id="sceneCanvas"></canvas>
<p>
    Γωνίας Θέασης: <input type="text" id="viewAngle" value="80" autocomplete="off">
    Ορθογώνιας απόστασης: <input type="text" id="viewDistance" value="9" autocomplete="off">
    <button id="drawSceneButton" onclick="drawScene()">Επανασχεδίαση!</button>
</p>
<p>
    <fieldset>
        <legend>Θέση κάμερας:</legend>
        <input type="radio" id="viewCameraButton0" name="viewCameraButton" value="0" checked/>Left-Front-Top <br>
        <input type="radio" id="viewCameraButton1" name="viewCameraButton" value="1"/>Left-Front-Bottom <br>
        <input type="radio" id="viewCameraButton2" name="viewCameraButton" value="2"/>Left-Back-Top <br>
        <input type="radio" id="viewCameraButton3" name="viewCameraButton" value="3"/>Left-Back-Bottom <br>
        <input type="radio" id="viewCameraButton4" name="viewCameraButton" value="4"/>Right-Front-Top <br>
        <input type="radio" id="viewCameraButton5" name="viewCameraButton" value="5"/>Right-Front-Bottom <br>
        <input type="radio" id="viewCameraButton6" name="viewCameraButton" value="6"/>Right-Back-Top <br>
        <input type="radio" id="viewCameraButton7" name="viewCameraButton" value="7"/>Right-Back-Bottom
    </fieldset>
</p>
</body>
</html>
